/**
 * Copyright (c) 2014 - 2015 Tolga Cakir <tolga@cevel.net>
 *
 * This source file is part of Game Capture HD Linux driver and is distributed
 * under the MIT License. For more information, see LICENSE file.
 */

#include <vector>
#include <cmath>
#include <iostream>
#include "../gchd.hpp"


//This runs the commands for all configurations up until a point they diverge
//badly in a way we haven't been unable to untangle yet.
void GCHD::configureDevice()
{
    std::vector<unsigned char> version;
    readVersion( version );
    std::cerr << "Hardware revision is " << version.data() << std::endl;

    //register is named BANKSEL from script files.
    write_config<uint16_t>(BANKSEL, 0x0000);

    //Get what is enabled in case we aren't in boot state, we may need to disable
    savedEnableStateRegister_ = read_config<uint16_t>(MAIL_SEND_ENABLE_REGISTER_STATE);

    //Okay, when we first read SCMD_STATE_READBACK_REGISTER
    //To get our current state, it actually TRIGGERS a state change.
    //but only in the case that the current state
    //(as read from SCMD_STATE_READBACK_REGISTER)
    //is already 0.
    uint16_t state;
    if( deviceType_ == DeviceType::GameCaptureHD )
    {
        //Since currentState and nextState are set to 0,
        //This will error out without waiting for the state
        //change to complete if we are in another state
        //which means the flash is loaded.
        //The error will be signified by state != 0
        //Otherwise it will do the transition.
        state=completeStateChange(0x0000, 0x0000);
    }
    else if( deviceType_ == DeviceType::GameCaptureHDNew )
    {
        //We can't use completeStateChange for HDNew,
        //as the read triggers an interrupt, which
        //the normal completeStateChange code doesn't handle.
        bool changed;
        state=read_config<uint16_t>(SCMD_STATE_READBACK_REGISTER);
        state &= 0x1f; //Ignore any other bits other than the ones we care about.

        if( state == 0x0000 )
        {
            interruptPend();
            do
            {
                uint16_t completion=read_config<uint16_t>(SCMD_STATE_CHANGE_COMPLETE);
                changed = (completion & 0x4)>0; //Check appropriate bit
            } while (!changed);

            //Reset sticky bit/acknowledge.
            write_config<uint16_t>(SCMD_STATE_CHANGE_COMPLETE, 0x0004);
        }
    }
    if( state == 0x0000) //We have to load the flash
    {
    	// load "idle" firmware
	    dlfirm(firmwareIdle_.c_str());

        //no idea what this does.
        write_config<uint16_t>(0xbc, 0x0900, 0x0070, 0x0004);

        savedEnableStateRegister_= read_config<uint16_t>(MAIL_SEND_ENABLE_REGISTER_STATE);
        savedEnableRegister_= read_config<uint16_t>(ENABLE_REGISTER);

        //Not sure what any of this is done for, but it appears we read 2 banks
        // of things
        //that are identical.
        read_config(0xbc, 0x0000, 0x0010, 2); //EXPECTED=0x20, 0x13
        read_config(0xbc, 0x0000, 0x0012, 2); //EXPECTED=0x12, 0x10
        read_config(0xbc, 0x0000, 0x0014, 2); //EXPECTED=0x18, 0x80
        read_config(0xbc, 0x0000, 0x0016, 2); //EXPECTED=0x20, 0x30
        read_config(0xbc, 0x0000, 0x0018, 2); //EXPECTED=0x20, 0x13
        read_config(0xbc, 0x0000, 0x001a, 2); //EXPECTED=0x12, 0x10
        read_config(0xbc, 0x0000, 0x001c, 2); //EXPECTED=0x18, 0x80
        read_config(0xbc, 0x0000, 0x001e, 2); //EXPECTED=0x20, 0x30
    }
    else
    {
        /* Oh, we were already up. Reset to known state, and flash
         * doesn't need to be loaded
         */
        stateConfirmedScmd( SCMD_RESET, 0x00, 0x0000 );
    }
    stateConfirmedScmd( SCMD_IDLE, 0x00, 0x0000 );

    specialDetectMask_ = 0xffff; //We are going to use this to auto-detect what
                                 //type of signal is incoming.

    //Confirm that we are up
    mailWrite( 0x33, VC{0xab, 0xa9, 0x0f, 0xa4, 0x55} );
    mailRead( 0x33, 3 ); //EXPECTED {0x33, 0x44, 0x55}

    std::vector<unsigned char> input=std::vector<unsigned char>(0);

    bool loopDone=false;
    uint32_t deviceModeMagic;
    bool firstTime=true;

    while(!loopDone)
    {
        mailWrite( 0x33, {0xab, 0xa9, 0x0f, 0xa4, 0x55} );
        input=mailRead( 0x33, 3 ); /* read 3 bytes from 0x33 */

        //Get magic number requested from port 0x33 last state.
        //Convert 3 bytes into one 24 bit number.
        deviceModeMagic=
             Utility::debyteify<uint32_t>(input.data(), 3);


        switch( deviceModeMagic ) {
            case 0x334455: //First device magic number we read back,
                           //We loop on this till it transitions to 0x27f97b
            {
                //TURN ON PROCESSOR
                sendEnableState();
                enableAnalogInput();
                doEnable( EB_FIRMWARE_PROCESSOR, EB_FIRMWARE_PROCESSOR );
            }
            break;

            case 0x27f97b:
            {
                if (firstTime ) {
                    bool hdmiSignalFound = (( specialDetectMask_ >> 3) & 1) != 0;
                    unsigned cableType = specialDetectMask_  & 3;
                    bool signalFound;

                    if( cableType == 0 ) {
                        signalFound=hdmiSignalFound;
                    } else {
                        signalFound=true;
                    }

                    InputSource autodetectInputSource = InputSource::Unknown;
                    if( !signalFound ) {
                        autodetectInputSource=InputSource::HDMI;
                    } else {
                        switch(cableType)
                        {
                            case 3:
                                autodetectInputSource=InputSource::Composite;
                                break;
                            case 2:
                                autodetectInputSource=InputSource::Component;
                                break;
                            case 0:
                                autodetectInputSource=InputSource::HDMI;
                                break;
                            default:
                                if( passedInputSettings_.getSource() == InputSource::Unknown ) {
                                    throw runtime_error("Unable to detect input source.");
                                }
                                break;
                        }
                    }
                    bool forced=false;
                    if( passedInputSettings_.getSource() == InputSource::Unknown ) {
                        currentInputSettings_.setSource( autodetectInputSource );
                    } else {
                        forced=true;
                        currentInputSettings_.setSource( passedInputSettings_.getSource() );
                    }
                    if ((!signalFound) && (!forced)) {
                        std::cerr << "No signal found. Defaulting to HDMI." << std::endl;
                        forced=true;
                    }
                    switch( currentInputSettings_.getSource() ) {
                        case InputSource::HDMI:
                            std::cerr << "HDMI input ";
                            break;
                        case InputSource::Component:
                            std::cerr << "Component input ";
                            break;
                        case InputSource::Composite:
                            std::cerr << "Composite input ";
                            break;
                        case InputSource::Unknown:
                            throw std::logic_error("Failed to set source.");
                            break;
                    }
                    if( forced ) {
                        std::cerr << "forced." << std::endl;;
                    } else {
                        std::cerr << "found." << std::endl;
                    }
                }

                //THis number is the 2nd number we read
                //back, and we end up repeating this after
                //main_initialize until the initialization is done.
                //Then we transition to 0x78e045, and we then come back here.
                enableAnalogInput();

                if( firstTime )  {

                    transcoderDefaultsInitialize();         //just came back from here.
                	scmd(SCMD_INIT, 0x00, 0x0000);
	
                    dlfirm(firmwareEnc_.c_str());

                    firstTime=false;
                	read_config<uint16_t>(0xbc, 0x0000, 0x0010); //EXPECTED=0x2013
                	read_config<uint16_t>(0xbc, 0x0000, 0x0012); //EXPECTED=0x1210
                	read_config<uint16_t>(0xbc, 0x0000, 0x0014); //EXPECTED=0x1880
                	read_config<uint16_t>(0xbc, 0x0000, 0x0016); //EXPECTED=0x2030
                    //Note that it is possible after firmware load for us to fallback
                    //temporarily to 0x334455 on some devices.

                } else {
                    loopDone=true;
                }

            }
            break;
        }
    }
    do {
        mailWrite( 0x33, {0xab, 0xa9, 0x0f, 0xa4, 0x5b} );
        input=mailRead( 0x33, 3 ); /* read 3 bytes from 0x33 */
        enableAnalogInput();
        deviceModeMagic=
             Utility::debyteify<uint32_t>(input.data(), 3);
    } while(deviceModeMagic != 0x78e045);
    doEnable( EB_ENCODER_ENABLE, EB_ENCODER_ENABLE );

    //We can go back to 0x334455 after we turn on EB_ENCODER_ENABLE in some cases,
    //Wait till we are 0x27f97b
    do
    {
        mailWrite( 0x33, {0xab, 0xa9, 0x0f, 0xa4, 0x55} );
        input=mailRead( 0x33, 3 ); /* read 3 bytes from 0x33 */
        deviceModeMagic=
            Utility::debyteify<uint32_t>(input.data(), 3);
    } while( deviceModeMagic != 0x27f97b );

    mailWrite( 0x33, VC{0x28, 0x28} );
    mailWrite( 0x33, VC{0x29, 0x89, 0x5b} );
    mailRead( 0x33, 1 ); //EXPECTED {0x91}
    mailWrite( 0x33, VC{0xdd, 0xce, 0x3f, 0xb2} );
    mailRead( 0x33, 2 ); //EXPECTED {0xda, 0x67}

    doEnable( EB_ENCODER_TRIGGER, EB_ENCODER_TRIGGER ); //Turn on trigger bit
    do
    {
        mailWrite( 0x33, VC{0x43, 0x23, 0x84} );
        input=mailRead( 0x33, 1 ); //EXPECTED {0xf7}
    } while(input[0] != 0xf7);
    doEnable( EB_ENCODER_TRIGGER, 0 ); //Turn off trigger bit

 	mailWrite( 0x33, VC{0x89, 0x89, 0xfb} );
	mailRead( 0x33, 1 ); //EXPECTED {0x6e}

    //Potential subroutine
    {
	    mailWrite( 0x44, VC{0x02, 0xc9} );
    	mailWrite( 0x44, VC{0x14, 0xd2} );
	    mailWrite( 0x44, VC{0x3c, 0x6b} );
    	mailWrite( 0x33, VC{0x89, 0x89, 0xfa} );
    	mailRead( 0x33, 1 ); //EXPECTED {0xed}
    }
	mailWrite( 0x33, VC{0x89, 0x89, 0xca} );
	mailRead( 0x33, 1 ); //EXPECTED {0xee}
	mailWrite( 0x33, VC{0x89, 0x89, 0xe7} );
	mailRead( 0x33, 1 ); //EXPECTED {0x49}
	mailWrite( 0x44, VC{0x03, 0x2a} );
	mailWrite( 0x44, VC{0x05, 0x89} );

    //This is an educated guess right now as to why it
    //set one way or the other. Currently it presumed
    //that it doesn't really matter much because
    //the old configure scripts didn't seem to match
    //captures that I've seen.
    bool analog = currentInputSettings_.getSource() != InputSource::HDMI;
    if( analog ) {
    	mailWrite( 0x44, VC{0x08, 0x91} );
	    mailWrite( 0x44, VC{0x09, 0xa8} );
    } else {
    	mailWrite( 0x44, VC{0x08, 0x9b} );
	    mailWrite( 0x44, VC{0x09, 0x7a} );
    }
	mailWrite( 0x44, VC{0x19, 0xde} );
	mailWrite( 0x44, VC{0x1a, 0x87} );
	mailWrite( 0x44, VC{0x1b, 0x88} );
	mailWrite( 0x44, VC{0x29, 0x8b} );
	mailWrite( 0x44, VC{0x2d, 0x8f} );
	mailWrite( 0x44, VC{0x4c, 0x89} );
	mailWrite( 0x44, VC{0x55, 0x88} );
	mailWrite( 0x44, VC{0x6b, 0xae} );
	mailWrite( 0x44, VC{0x6c, 0xbe} );
	mailWrite( 0x44, VC{0x6d, 0x78} );
	mailWrite( 0x44, VC{0x6e, 0xa0} );
	mailWrite( 0x44, VC{0x06, 0x08} );

    //Potential subroutine
    {
	    mailWrite( 0x44, VC{0x02, 0xc9} );
    	mailWrite( 0x44, VC{0x14, 0xd2} );
	    mailWrite( 0x44, VC{0x3c, 0x6b} );
	    mailWrite( 0x33, VC{0x89, 0x89, 0xfa} );
	    mailRead( 0x33, 1 ); //EXPECTED {0xfd}
    }
	mailWrite( 0x44, VC{0x28, 0x88} );
	mailWrite( 0x44, VC{0x10, 0x88} );
	mailWrite( 0x44, VC{0x11, 0xd4} );
	mailWrite( 0x44, VC{0x12, 0xd0} );
	mailWrite( 0x44, VC{0x13, 0x08} );
	mailWrite( 0x44, VC{0x14, 0x08} );
	mailWrite( 0x44, VC{0x15, 0x88} );
	mailWrite( 0x33, VC{0x94, 0x47, 0xf9} );
	mailWrite( 0x33, VC{0x94, 0x40, 0xf3} );
	mailWrite( 0x33, VC{0x94, 0x43, 0xb7} );
	mailWrite( 0x33, VC{0x94, 0x4e, 0xb7} );
	mailWrite( 0x33, VC{0x94, 0x4f, 0xb7} );
	mailWrite( 0x33, VC{0x94, 0x48, 0xb7} );
	mailWrite( 0x33, VC{0x94, 0x49, 0xb7} );
	mailWrite( 0x33, VC{0x94, 0x58, 0x77} );
	mailWrite( 0x33, VC{0x94, 0x40, 0xf1} );
	mailWrite( 0x33, VC{0x94, 0x4d, 0xf5} );
	mailWrite( 0x33, VC{0x94, 0x4a, 0xaf} );
	mailWrite( 0x33, VC{0x94, 0x4b, 0xaf} );
	mailWrite( 0x33, VC{0x94, 0x5c, 0xb7} );
	mailWrite( 0x33, VC{0x94, 0x46, 0xd7} );

	readDevice0x9DCD(0x88); //EXPECTED 0xb2
	mailWrite( 0x4e, VC{0xb7, 0xce} );
	mailWrite( 0x4e, VC{0x41, 0xa3} );
	mailWrite( 0x4e, VC{0xb8, 0xcc} );
	readDevice0x9DCD(0x3f); //EXPECTED 0xb2
	mailWrite( 0x4e, VC{0x00, 0xcd} );
	mailWrite( 0x4e, VC{0x0f, 0xce} );
	mailWrite( 0x4e, VC{0x16, 0xfc} );
	mailWrite( 0x4e, VC{0x17, 0xcc} );
	mailWrite( 0x4e, VC{0x18, 0xcc} );
	mailWrite( 0x4e, VC{0x19, 0xcc} );
	mailWrite( 0x4e, VC{0x1a, 0x9c} );
	readDevice0x9DCD(0x15); //EXPECTED 0xb2
	mailWrite( 0x4e, VC{0x2a, 0xcb} );
	readDevice0x9DCD(0x3f); //EXPECTED 0xb3
	mailWrite( 0x4e, VC{0x00, 0xce} );
	mailWrite( 0x4e, VC{0x08, 0xcf} );
	readDevice0x9DCD(0x3f); //EXPECTED 0xb0
	mailWrite( 0x4e, VC{0x00, 0xcd} );
    if ( deviceType_ == DeviceType::GameCaptureHDNew )
    {
	    mailWrite( 0x4e, VC{0x24, 0x8c} );
    } else {
    	mailWrite( 0x4e, VC{0x24, 0x8d} );
    }
	mailWrite( 0x4e, VC{0x25, 0xcc} );
	mailWrite( 0x4e, VC{0x30, 0x4c} );
	mailWrite( 0x4e, VC{0x31, 0xcc} );
	mailWrite( 0x4e, VC{0x32, 0xcc} );
	mailWrite( 0x4e, VC{0x25, 0xcc} );
	mailWrite( 0x4e, VC{0x26, 0xcc} );
	mailWrite( 0x4e, VC{0x27, 0xcc} );
	mailWrite( 0x4e, VC{0x27, 0xcc} );
	mailWrite( 0x4e, VC{0x27, 0xcc} );
	mailWrite( 0x4e, VC{0x27, 0xcc} );
	mailWrite( 0x4e, VC{0x27, 0xcc} );
	readDevice0x9DCD(0x3f); //EXPECTED 0xb3
	mailWrite( 0x4e, VC{0x00, 0xcc} );
	mailWrite( 0x4e, VC{0xb0, 0xe8} );
	readDevice0x9DCD(0x91); //EXPECTED 0xb2
	mailWrite( 0x4e, VC{0xae, 0xc8} );
	mailWrite( 0x4e, VC{0xb1, 0x0c} );
	mailWrite( 0x4e, VC{0xb2, 0xcc} );
	mailWrite( 0x4e, VC{0xb3, 0xcc} );
	mailWrite( 0x4e, VC{0xb4, 0x99} );
	readDevice0x9DCD(0x8b); //EXPECTED 0xe7
	mailWrite( 0x4e, VC{0xb4, 0x98} );
	readDevice0x9DCD(0x3f); //EXPECTED 0xb2
	mailWrite( 0x4e, VC{0x00, 0xce} );
	mailWrite( 0x4e, VC{0x01, 0xad} );
	mailWrite( 0x4e, VC{0x02, 0x39} );
	readDevice0x9DCD(0x3c); //EXPECTED 0xb2
	mailWrite( 0x4e, VC{0x03, 0xce} );
	mailWrite( 0x4e, VC{0x04, 0xcd} );
	mailWrite( 0x4e, VC{0x05, 0xcc} );
	mailWrite( 0x4e, VC{0x06, 0xc4} );
	mailWrite( 0x4e, VC{0x1c, 0xd6} );
	mailWrite( 0x4e, VC{0x1d, 0xcc} );
	mailWrite( 0x4e, VC{0x1e, 0xcc} );
	mailWrite( 0x4e, VC{0x1f, 0xcc} );
	readDevice0x9DCD(0x1a); //EXPECTED 0xb2
	mailWrite( 0x4e, VC{0x25, 0x6e} );
	readDevice0x9DCD(0x3d); //EXPECTED 0x47
	mailWrite( 0x4e, VC{0x02, 0x39} );
	readDevice0x9DCD(0x38); //EXPECTED 0xb2
	mailWrite( 0x4e, VC{0x07, 0xc8} );
	mailWrite( 0x4e, VC{0x17, 0x0c} );
	mailWrite( 0x4e, VC{0x19, 0x33} );
	mailWrite( 0x4e, VC{0x1a, 0x33} );
	mailWrite( 0x4e, VC{0x1b, 0x30} );
	mailWrite( 0x4e, VC{0x20, 0xcc} );
	readDevice0x9DCD(0x1e); //EXPECTED 0xb2
	mailWrite( 0x4e, VC{0x21, 0xcc} );
	mailWrite( 0x4e, VC{0x22, 0xea} );
	mailWrite( 0x4e, VC{0x27, 0xcc} );
	readDevice0x9DCD(0x11); //EXPECTED 0xb2
	mailWrite( 0x4e, VC{0x2e, 0x6d} );
	mailWrite( 0x33, VC{0x99, 0x89, 0xfa} );
	mailRead( 0x33, 1 ); //EXPECTED {0xa4}
	mailWrite( 0x33, VC{0x99, 0x89, 0xf9} );
	mailRead( 0x33, 1 ); //EXPECTED {0x7f}
	mailWrite( 0x33, VC{0x99, 0x89, 0xf8} );
	mailRead( 0x33, 1 ); //EXPECTED {0x78}
	mailWrite( 0x33, VC{0x99, 0x89, 0xfe} );
	mailRead( 0x33, 1 ); //EXPECTED {0x0e}
	mailWrite( 0x4c, VC{0x05, 0x88} );
	mailWrite( 0x4c, VC{0x04, 0xb5} );
	mailWrite( 0x4c, VC{0x04, 0x95} );
	mailWrite( 0x4c, VC{0x61, 0xb8} );
	mailWrite( 0x4c, VC{0x09, 0x3a} );
	mailWrite( 0x4c, VC{0x0a, 0x70} );
	mailWrite( 0x4c, VC{0x0b, 0xbf} );
	mailWrite( 0x4c, VC{0xc9, 0x88} );
	mailWrite( 0x4c, VC{0xca, 0x88} );
	mailWrite( 0x4c, VC{0xcb, 0x88} );
	mailWrite( 0x4c, VC{0xcc, 0x88} );
	mailWrite( 0x4c, VC{0xcd, 0x88} );
	mailWrite( 0x4c, VC{0xce, 0x88} );
	mailWrite( 0x4c, VC{0xcf, 0x88} );
	mailWrite( 0x4c, VC{0xd0, 0x88} );

    if ( deviceType_ == DeviceType::GameCaptureHDNew )
    {
        mailWrite( 0x33, VC{0x21, 0x01, 0x72} );
        mailRead( 0x33, 1 ); //EXPECTED {0xf4}
        mailWrite( 0x33, VC{0x20, 0x02, 0x63} );
        mailWrite( 0x33, VC{0x20, 0x03, 0x63} );
        mailWrite( 0x33, VC{0x20, 0x04, 0x77} );
        mailWrite( 0x33, VC{0x20, 0x05, 0x73} );
        mailWrite( 0x33, VC{0x20, 0x06, 0x73} );
        mailWrite( 0x33, VC{0x20, 0x07, 0x33} );
        mailWrite( 0x33, VC{0x20, 0x08, 0x31} );
        mailWrite( 0x33, VC{0x20, 0x09, 0x33} );
        mailWrite( 0x33, VC{0x20, 0x0a, 0x57} );
        mailWrite( 0x33, VC{0x20, 0x0b, 0x7b} );
        mailWrite( 0x33, VC{0x20, 0x0c, 0xf7} );
        mailWrite( 0x33, VC{0x20, 0x0d, 0xf7} );
        mailWrite( 0x33, VC{0x20, 0x0e, 0x73} );
        mailWrite( 0x33, VC{0x20, 0x0f, 0x73} );
    }
    mailWrite( 0x33, VC{0xaa, 0x8f, 0x3b} );


    //----------------------------------------------------------

    //The next set of writes and the laster 56 byte reads
    //are not understood at  all.
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x03, 0x76} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x3b, 0x76} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x73, 0x76} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0xab, 0x76} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0xe3, 0x76} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x1b, 0x77} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x53, 0x77} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x8b, 0x77} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0xc3, 0x77} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0xfb, 0x77} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x33, 0x74} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x6b, 0x74} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0xa3, 0x74} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0xdb, 0x74} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x13, 0x75} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x4b, 0x75} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x83, 0x75} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0xbb, 0x75} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0xf3, 0x75} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x2b, 0x72} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x63, 0x72} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x9b, 0x72} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0xd3, 0x72} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x0b, 0x73} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x43, 0x73} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x7b, 0x73} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0xb3, 0x73} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0xeb, 0x73} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x23, 0x70} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x5b, 0x70} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x93, 0x70} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0xcb, 0x70} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x03, 0x71} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x3b, 0x71} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x73, 0x71} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0xab, 0x71} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0xe3, 0x71} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x1b, 0x7e} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x53, 0x7e} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x8b, 0x7e} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0xc3, 0x7e} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0xfb, 0x7e} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x33, 0x7f} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x6b, 0x7f} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0xa3, 0x7f} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0xdb, 0x7f} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x13, 0x7c} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x4b, 0x7c} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x83, 0x7c} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0xbb, 0x7c} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0xf3, 0x7c} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x2b, 0x7d} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x63, 0x7d} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x9b, 0x7d} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0xd3, 0x7d} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x0b, 0x7a} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x43, 0x7a} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x7b, 0x7a} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0xb3, 0x7a} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0xeb, 0x7a} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x23, 0x7b} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x5b, 0x7b} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x93, 0x7b} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0xcb, 0x7b} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x03, 0x78} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x3b, 0x78} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x73, 0x78} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0xab, 0x78} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0xe3, 0x78} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x1b, 0x79} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x53, 0x79} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0x8b, 0x79} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0x92, 0x3e, 0xb4, 0xc3, 0x79} );
	mailRead( 0x33, 56 );
	mailWrite( 0x33, VC{0xab, 0xa2, 0x3e, 0xb4, 0xfb, 0x79} );


	mailRead( 0x33, 8 ); //EXPECTED {0xe9, 0x5c, 0xcf, 0x42, 0xb5, 0x28, 0x9b, 0x0e}
	mailWrite( 0x33, VC{0xaa, 0x8d, 0x35} );
    do {
        mailWrite( 0x33, {0xab, 0xa9, 0x0f, 0xa4, 0x5b} );
        input=mailRead( 0x33, 3 ); /* read 3 bytes from 0x33 */
        enableAnalogInput();
        deviceModeMagic=
            Utility::debyteify<uint32_t>(input.data(), 3);
    } while(deviceModeMagic != 0x78e045);

    transcoderSetup( currentInputSettings_, currentTranscoderSettings_ );
    transcoderOutputEnable(true);

    analog = currentInputSettings_.getSource() != InputSource::HDMI;
    bool composite = currentInputSettings_.getSource() == InputSource::Composite;

    scmd(SCMD_INIT, 0xa0, 0x0000);
    if( !composite )  {
       mailWrite( 0x44, VC{0x06, 0x86} );
    } else {
       mailWrite( 0x33, VC{0x89, 0x89, 0xfd} );
       mailRead( 0x33, 1 ); //EXPECTED {0x6e}
    }
    mailWrite( 0x33, VC{0x89, 0x89, 0xf8} );
    mailRead( 0x33, 1 ); //EXPECTED {0xcc}

    if( !composite ) {
        mailWrite( 0x44, VC{0x03, 0x2f} );
    } else {
        mailWrite( 0x44, VC{0x03, 0x28} );
    }
    readDevice0x9DCD(0x3f); //EXPECTED 0xb0
    mailWrite( 0x4e, VC{0x00, 0xcc} );
    if( !composite ) {
        mailWrite( 0x4e, VC{0xb3, 0xcc} );
    } else {
        mailWrite( 0x4e, VC{0xb3, 0x33} );
    }
    readDevice0x9DCD(0x3f); //EXPECTED 0xb2
    mailWrite( 0x4e, VC{0x00, 0xce} );
    if( !composite ) {
        mailWrite( 0x4e, VC{0x27, 0xcc} );
    } else {
        mailWrite( 0x4e, VC{0x27, 0x33} );
        readDevice0x9DCD(0x3f);
        mailWrite( 0x4e, VC{0x00, 0xcc} );
        readDevice0x9DCD(0x6e);
        mailWrite( 0x4e, VC{0x51, 0xcc} );
    }
    doEnable( EB_COMPOSITE_MUX, composite ? EB_COMPOSITE_MUX: 0);
    doEnable( EB_ANALOG_INPUT, analog ? EB_ANALOG_INPUT: 0);
    doEnable( EB_ANALOG_MUX, analog ? EB_ANALOG_MUX:0);


    switch (currentInputSettings_.getSource())
    {
        case InputSource::HDMI:
            configureHDMI();
            break;
       case InputSource::Component:
            configureComponent();
            break;
        case InputSource::Composite:
            configureComposite();
            break;
        case InputSource::Unknown:
        default:
            throw runtime_error("Unknown input source not currently allowed.");
            break;
    }
}


void GCHD::uninitDevice()
{
    uint16_t state=read_config<uint16_t>(SCMD_STATE_READBACK_REGISTER) & 0x1f;
    if(( state == SCMD_STATE_START ) || ( state==SCMD_STATE_NULL )) {
        stopStream( true );
    }

    //0x12 means already unininitialized (SCMD_RESET with mode=0x1),
    //0x10 means already unininitialized (SCMD_RESET with mode=0x0).
    //ox00 means never initialized.
    if(( state != 0x12 ) && (state != 0x00) && (state != 0x10)) {
        //Mystery subroutine, done after an SCMD_INIT too.
        {
            mailWrite( 0x44, VC{0x06, 0x86} );
            mailWrite( 0x33, VC{0x89, 0x89, 0xf8} );
            mailRead( 0x33, 1 ); //EXPECTED {0xc9}
            mailWrite( 0x44, VC{0x03, 0x2f} );
        }
        //No idea what this is, but presumably selects proper bank.
        //Seems to be always done before configuring the transcoder with
        //sparam commands.
        write_config<uint16_t>(BANKSEL, 0x0000);
        readEnableState(); //EXPECTED 0xd39e HD NEW. 0x31e on HD

        read_config<uint16_t>(SCMD_STATE_READBACK_REGISTER); //seems no reason for this read..
        transcoderOutputEnable( false );
        scmd(SCMD_INIT, 0xa0, 0x0000);

        clearEnableState();

        //This command appears to do nothing, it appears to be a doEnable
        //for a bit that we can't identify, that isn't configured
        //in any of our test cases.
        doEnable(EB_FIRMWARE_PROCESSOR, 0x0);

        stateConfirmedScmd( SCMD_IDLE, 0x00, 0x0000 );
        stateConfirmedScmd( SCMD_RESET, 0x01, 0x0000 );
    }
}

void GCHD::configureColorSpace()
{
    //Only reason this is included here is because it clearly comes before
    //color space configuration in the original driver thread.
    if (currentInputSettings_.getSource() == InputSource::Component) {
        mailWrite( 0x4e, VC{0x0b, 0x4c} );
        mailWrite( 0x4e, VC{0x0c, 0x4c} );
        mailWrite( 0x4e, VC{0x0d, 0x4c} );
        mailWrite( 0x4e, VC{0x08, 0x4c} );
        mailWrite( 0x4e, VC{0x09, 0x4c} );
        mailWrite( 0x4e, VC{0x0a, 0x4c} );
        mailWrite( 0x4e, VC{0x1e, 0x98} );
        mailWrite( 0x4e, VC{0x1f, 0xc9} );
    }

    if( currentInputSettings_.getColorSpace()==ColorSpace::YUV ) {
        //Set up color space.
        mailWrite( 0x4e, VC{0x92, 0xaa} );
        mailWrite( 0x4e, VC{0x93, 0xdc} );
        mailWrite( 0x4e, VC{0x94, 0xcc} );
        mailWrite( 0x4e, VC{0x95, 0xcc} );
        mailWrite( 0x4e, VC{0x96, 0xcc} );
        mailWrite( 0x4e, VC{0x97, 0xcc} );
        mailWrite( 0x4e, VC{0x98, 0xcc} );
        mailWrite( 0x4e, VC{0x99, 0xcc} );
        mailWrite( 0x4e, VC{0x9a, 0xcc} );
        mailWrite( 0x4e, VC{0x9b, 0xdc} );
        mailWrite( 0x4e, VC{0x9c, 0xcc} );
        mailWrite( 0x4e, VC{0x9d, 0xcc} );
        mailWrite( 0x4e, VC{0x9e, 0xcc} );
        mailWrite( 0x4e, VC{0x9f, 0xcc} );
        mailWrite( 0x4e, VC{0xa0, 0xcc} );
        mailWrite( 0x4e, VC{0xa1, 0xcc} );
        mailWrite( 0x4e, VC{0xa2, 0xcc} );
        mailWrite( 0x4e, VC{0xa3, 0xdc} );
        mailWrite( 0x4e, VC{0xa4, 0xcc} );
        mailWrite( 0x4e, VC{0xa5, 0xec} );
        mailWrite( 0x4e, VC{0xa6, 0xcc} );
        mailWrite( 0x4e, VC{0xa7, 0xc8} );
        mailWrite( 0x4e, VC{0xa8, 0xcd} );
        mailWrite( 0x4e, VC{0xa9, 0xec} );
        mailWrite( 0x4e, VC{0xaa, 0xcc} );
    } else {
        mailWrite( 0x4e, VC{0x92, 0x8c} );
        mailWrite( 0x4e, VC{0x93, 0xcb} );
        mailWrite( 0x4e, VC{0x94, 0xca} );
        mailWrite( 0x4e, VC{0x95, 0xce} );
        mailWrite( 0x4e, VC{0x96, 0x22} );
        mailWrite( 0x4e, VC{0x97, 0xb2} );
        mailWrite( 0x4e, VC{0x98, 0xae} );
        mailWrite( 0x4e, VC{0x99, 0xb5} );
        mailWrite( 0x4e, VC{0x9a, 0x52} );
        mailWrite( 0x4e, VC{0x9b, 0xc5} );
        mailWrite( 0x4e, VC{0x9c, 0x1f} );
        mailWrite( 0x4e, VC{0x9d, 0xb6} );
        mailWrite( 0x4e, VC{0x9e, 0x54} );
        mailWrite( 0x4e, VC{0x9f, 0xb3} );
        mailWrite( 0x4e, VC{0xa0, 0x90} );
        mailWrite( 0x4e, VC{0xa1, 0xcc} );
        mailWrite( 0x4e, VC{0xa2, 0x32} );
        mailWrite( 0x4e, VC{0xa3, 0xcb} );
        mailWrite( 0x4e, VC{0xa4, 0xca} );
        mailWrite( 0x4e, VC{0xa5, 0xec} );
        mailWrite( 0x4e, VC{0xa6, 0xcc} );
        mailWrite( 0x4e, VC{0xa7, 0xc8} );
        mailWrite( 0x4e, VC{0xa8, 0xcd} );
        mailWrite( 0x4e, VC{0xa9, 0xec} );
        mailWrite( 0x4e, VC{0xaa, 0xcc} );
    }

    //Only reason this is included here is because it clearly comes next
    //in the original driver thread.
    if (currentInputSettings_.getSource() == InputSource::Component) {
        switch(currentInputSettings_.getResolution()) {
            case Resolution::HD1080:
                mailWrite( 0x4e, VC{0xb2, 0xcc} );
                mailWrite( 0x4e, VC{0xb5, 0xc4} );

                if( currentInputSettings_.getScanMode()==ScanMode::Interlaced) { //1080i60
                    mailWrite( 0x4e, VC{0x03, 0x0c} );
                } else { //1080p30
                    mailWrite( 0x4e, VC{0x03, 0x04} );
                }
                break;
            case Resolution::HD720:
                mailWrite( 0x4e, VC{0xb2, 0xcc} );
                mailWrite( 0x4e, VC{0xb5, 0xc4} );
                mailWrite( 0x4e, VC{0x03, 0x8c} );
                break;
            case Resolution::PAL: //Same setup here.
            case Resolution::NTSC:
                mailWrite( 0x4e, VC{0xb2, 0xcf} );
                mailWrite( 0x4e, VC{0xb5, 0xc4} );

                if( currentInputSettings_.getScanMode()==ScanMode::Interlaced) {
                    mailWrite( 0x4e, VC{0x03, 0x8c} );
                } else {
                    mailWrite( 0x4e, VC{0x03, 0x84} );
                }
                break;
            default:
                throw runtime_error( "Current selected video mode is not a supported mode.");
                break;
        }
    }
}

void GCHD::configureSetupSubblock()
{
    mailWrite( 0x33, VC{0x99, 0x89, 0x8b} );
    mailRead( 0x33, 1 ); //EXPECTED {0x6e}

    switch(currentInputSettings_.getSource())
    {
        case InputSource::HDMI:
            mailWrite( 0x4c, VC{0x70, 0xc8} );
            mailWrite( 0x4c, VC{0x90, 0x88} );
            mailWrite( 0x4c, VC{0x91, 0x77} );
            mailWrite( 0x4c, VC{0x92, 0x77} );
            mailWrite( 0x4c, VC{0x93, 0x77} );
            mailWrite( 0x4c, VC{0x94, 0x77} );
            mailWrite( 0x4c, VC{0x95, 0x77} );
            mailWrite( 0x4c, VC{0x96, 0x77} );
            mailWrite( 0x4c, VC{0x97, 0x77} );
            mailWrite( 0x4c, VC{0x98, 0x77} );
            mailWrite( 0x4c, VC{0x99, 0x77} );
            mailWrite( 0x4c, VC{0x9a, 0x77} );
            mailWrite( 0x4c, VC{0x9b, 0x77} );
            mailWrite( 0x4c, VC{0x9c, 0x77} );
            mailWrite( 0x4c, VC{0x9d, 0x77} );
            mailWrite( 0x4c, VC{0x9e, 0x77} );
            mailWrite( 0x4c, VC{0x9f, 0x77} );
            mailWrite( 0x4c, VC{0xa0, 0x77} );
            mailWrite( 0x4c, VC{0xa1, 0x77} );
            mailWrite( 0x4c, VC{0xa2, 0x77} );
            mailWrite( 0x4c, VC{0xa3, 0x77} );
            break;

        //576i and 480i have the same setup on Component and Composite
        case InputSource::Component:
        case InputSource::Composite:
            switch(currentInputSettings_.getResolution())
            {
                case Resolution::HD1080:
                    if( currentInputSettings_.getScanMode()==ScanMode::Interlaced) {
                        mailWrite( 0x4c, VC{0x70, 0xc0} );
                        mailWrite( 0x4c, VC{0x0f, 0x88} );
                        mailWrite( 0x4c, VC{0x90, 0xae} );
                        mailWrite( 0x4c, VC{0x91, 0xc2} );
                        mailWrite( 0x4c, VC{0x95, 0xde} );
                        mailWrite( 0x4c, VC{0x96, 0x0a} );
                        mailWrite( 0x4c, VC{0x97, 0x88} );
                        mailWrite( 0x4c, VC{0xa0, 0x8a} );
                        mailWrite( 0x4c, VC{0xa1, 0xf8} );
                        mailWrite( 0x4c, VC{0xa2, 0xbc} );
                        mailWrite( 0x4c, VC{0xa3, 0x1a} );
                    } else { //Assuming HD1080p30
                        mailWrite( 0x4c, VC{0x70, 0xc0} );
                        mailWrite( 0x4c, VC{0x0f, 0x88} );
                        mailWrite( 0x4c, VC{0x90, 0x7e} );
                        mailWrite( 0x4c, VC{0x91, 0x77} );
                        mailWrite( 0x4c, VC{0x95, 0xde} );
                        mailWrite( 0x4c, VC{0x96, 0x0a} );
                        mailWrite( 0x4c, VC{0x97, 0x88} );
                        mailWrite( 0x4c, VC{0xa0, 0x8c} );
                        mailWrite( 0x4c, VC{0xa1, 0x18} );
                        mailWrite( 0x4c, VC{0xa2, 0x77} );
                        mailWrite( 0x4c, VC{0xa3, 0x77} );
                    }
                    break;
                case Resolution::HD720:
                    mailWrite( 0x4c, VC{0x70, 0xc0} );
                    mailWrite( 0x4c, VC{0x0f, 0x88} );
                    mailWrite( 0x4c, VC{0x90, 0xfe} );
                    mailWrite( 0x4c, VC{0x91, 0xbb} );
                    mailWrite( 0x4c, VC{0x95, 0xe4} );
                    mailWrite( 0x4c, VC{0x96, 0x1c} );
                    mailWrite( 0x4c, VC{0x97, 0x88} );
                    mailWrite( 0x4c, VC{0xa0, 0x8d} );
                    mailWrite( 0x4c, VC{0xa1, 0x28} );
                    mailWrite( 0x4c, VC{0xa2, 0x77} );
                    mailWrite( 0x4c, VC{0xa3, 0x77} );
                    break;
                case Resolution::PAL:
                    if( currentInputSettings_.getScanMode()==ScanMode::Interlaced) {
                        mailWrite( 0x4c, VC{0x70, 0xd0} );
                        mailWrite( 0x4c, VC{0x0f, 0x88} );
                        mailWrite( 0x4c, VC{0x90, 0xd8} );
                        mailWrite( 0x4c, VC{0x91, 0xbf} );
                        mailWrite( 0x4c, VC{0x95, 0x9d} );
                        mailWrite( 0x4c, VC{0x96, 0x1b} );
                        mailWrite( 0x4c, VC{0x97, 0x88} );
                        mailWrite( 0x4c, VC{0xa0, 0x8a} );
                        mailWrite( 0x4c, VC{0xa1, 0xd8} );
                        mailWrite( 0x4c, VC{0xa2, 0xb2} );
                        mailWrite( 0x4c, VC{0xa3, 0x59} );
                    } else {
                        mailWrite( 0x4c, VC{0x70, 0xc0} );
                        mailWrite( 0x4c, VC{0x0f, 0x88} );
                        mailWrite( 0x4c, VC{0x90, 0x28} );
                        mailWrite( 0x4c, VC{0x91, 0x93} );
                        mailWrite( 0x4c, VC{0x95, 0x82} );
                        mailWrite( 0x4c, VC{0x96, 0xc2} );
                        mailWrite( 0x4c, VC{0x97, 0x88} );
                        mailWrite( 0x4c, VC{0xa0, 0x8d} );
                        mailWrite( 0x4c, VC{0xa1, 0x28} );
                        mailWrite( 0x4c, VC{0xa2, 0x77} );
                        mailWrite( 0x4c, VC{0xa3, 0x77} );
                    }
                    break;
                case Resolution::NTSC:
                    if( currentInputSettings_.getScanMode()==ScanMode::Interlaced) {
                        mailWrite( 0x4c, VC{0x70, 0xd0} );
                        mailWrite( 0x4c, VC{0x0f, 0x88} );
                        mailWrite( 0x4c, VC{0x90, 0x68} );
                        mailWrite( 0x4c, VC{0x91, 0xbf} );
                        mailWrite( 0x4c, VC{0x95, 0xab} );
                        mailWrite( 0x4c, VC{0x96, 0x17} );
                        mailWrite( 0x4c, VC{0x97, 0x88} );
                        mailWrite( 0x4c, VC{0xa0, 0x8c} );
                        mailWrite( 0x4c, VC{0xa1, 0xf8} );
                        mailWrite( 0x4c, VC{0xa2, 0x82} );
                        mailWrite( 0x4c, VC{0xa3, 0x59} );
                    } else {
                        mailWrite( 0x4c, VC{0x70, 0xc0} );
                        mailWrite( 0x4c, VC{0x0f, 0x88} );
                        mailWrite( 0x4c, VC{0x90, 0x78} );
                        mailWrite( 0x4c, VC{0x91, 0xb9} );
                        mailWrite( 0x4c, VC{0x95, 0x86} );
                        mailWrite( 0x4c, VC{0x96, 0xc4} );
                        mailWrite( 0x4c, VC{0x97, 0x88} );
                        mailWrite( 0x4c, VC{0xa0, 0x81} );
                        mailWrite( 0x4c, VC{0xa1, 0x78} );
                        mailWrite( 0x4c, VC{0xa2, 0x77} );
                        mailWrite( 0x4c, VC{0xa3, 0x77} );
                    }
                    break;

                 default:
                    throw runtime_error( "Current selected video mode is not a supported mode.");
                    break;
            }
            break;
        default:
            throw runtime_error( "Unsupported input source.");
            break;
    }
}

void GCHD::configureCommonBlockA()
{
    mailWrite( 0x33, VC{0x99, 0x89, 0xfd} );
    mailRead( 0x33, 1 ); //EXPECTED {0x6e}
    mailWrite( 0x4c, VC{0x10, 0x89} );
    mailWrite( 0x4c, VC{0x15, 0x81} );
    mailWrite( 0x4c, VC{0x0f, 0x88} );
    mailWrite( 0x4c, VC{0x10, 0x89} );
    mailWrite( 0x4c, VC{0x15, 0x81} );
    mailWrite( 0x4c, VC{0x65, 0x8a} );
    mailWrite( 0x4c, VC{0x10, 0x89} );
    mailWrite( 0x4c, VC{0x11, 0x28} );
    mailWrite( 0x4c, VC{0x12, 0x88} );
    mailWrite( 0x4c, VC{0x13, 0xa8} );
    mailWrite( 0x4c, VC{0x14, 0x88} );
    mailWrite( 0x4c, VC{0x15, 0x8b} );
    pollOn0x9989ED();
    readFrom0x9989EC(32);
    mailWrite( 0x4c, VC{0x10, 0x89} );
    mailWrite( 0x4c, VC{0x15, 0x81} );
    mailWrite( 0x4c, VC{0x65, 0x8a} );
    mailWrite( 0x4c, VC{0x10, 0x89} );
    mailWrite( 0x4c, VC{0x11, 0x28} );
    mailWrite( 0x4c, VC{0x12, 0xa8} );
    mailWrite( 0x4c, VC{0x13, 0xa8} );
    mailWrite( 0x4c, VC{0x14, 0x88} );
    mailWrite( 0x4c, VC{0x15, 0x8b} );
    pollOn0x9989ED();
    readFrom0x9989EC(32);
    mailWrite( 0x4c, VC{0x10, 0x89} );
    mailWrite( 0x4c, VC{0x15, 0x81} );
    mailWrite( 0x4c, VC{0x65, 0x8a} );
    mailWrite( 0x4c, VC{0x10, 0x89} );
    mailWrite( 0x4c, VC{0x11, 0x28} );
    mailWrite( 0x4c, VC{0x12, 0xc8} );
    mailWrite( 0x4c, VC{0x13, 0xa8} );
    mailWrite( 0x4c, VC{0x14, 0x88} );
    mailWrite( 0x4c, VC{0x15, 0x8b} );
    pollOn0x9989ED();
    readFrom0x9989EC(32); //EXPECTED {0x2b, 0x6e, 0xce, 0x34, 0x6e, 0x6e, 0x6e, 0x70, 0x6f, 0x73, 0x6e, 0x1c, 0x3f, 0xbe, 0x70, 0x4e, 0x00, 0x46, 0x3b, 0x6e, 0xce, 0x34, 0x6e, 0x6e, 0x6e, 0x70, 0x6e, 0x6e, 0x6e, 0x93, 0x6e, 0x5c}
    mailWrite( 0x4c, VC{0x10, 0x89} );
    mailWrite( 0x4c, VC{0x15, 0x81} );
    mailWrite( 0x4c, VC{0x65, 0x8a} );
    mailWrite( 0x4c, VC{0x10, 0x89} );
    mailWrite( 0x4c, VC{0x11, 0x28} );
    mailWrite( 0x4c, VC{0x12, 0xe8} );
    mailWrite( 0x4c, VC{0x13, 0xa8} );
    mailWrite( 0x4c, VC{0x14, 0x88} );
    mailWrite( 0x4c, VC{0x15, 0x8b} );
    pollOn0x9989ED();
    readFrom0x9989EC(32); //EXPECTED {0x52, 0x70, 0x3f, 0x7f, 0x6e, 0x64, 0x4e, 0x4e, 0x4e, 0x4e, 0x4e, 0x4e, 0x6e, 0x6e, 0x6e, 0x92, 0x6e, 0x3d, 0x17, 0x00, 0x0d, 0x23, 0x0f, 0x1d, 0x1a, 0x0b, 0x1c, 0x64, 0x4e, 0x4e, 0x6f, 0xfa}

    mailWrite( 0x33, VC{0x99, 0x89, 0xfd} );
    mailRead( 0x33, 1 ); //EXPECTED {0x6e}
    mailWrite( 0x4c, VC{0x10, 0x89} );
    mailWrite( 0x4c, VC{0x15, 0x81} );
    mailWrite( 0x4c, VC{0x0f, 0x88} );
    mailWrite( 0x4c, VC{0x10, 0x89} );
    mailWrite( 0x4c, VC{0x15, 0x81} );
    mailWrite( 0x4c, VC{0x65, 0x8a} );
    mailWrite( 0x4c, VC{0x10, 0x89} );
    mailWrite( 0x4c, VC{0x11, 0x28} );
    mailWrite( 0x4c, VC{0x12, 0x08} );
    mailWrite( 0x4c, VC{0x13, 0xa8} );
    mailWrite( 0x4c, VC{0x14, 0x88} );
    mailWrite( 0x4c, VC{0x15, 0x8b} );
    pollOn0x9989ED();
    readFrom0x9989EC(32); //EXPECTED {0x6c, 0x6d, 0x72, 0x9f, 0x26, 0xfe, 0x6a, 0x71, 0x6b, 0x7a, 0x7d, 0x6d, 0x7c, 0x4d, 0x67, 0x69, 0x69, 0xed, 0x6f, 0x6e, 0x6e, 0x08, 0x6d, 0x62, 0x6e, 0x7e, 0x6e, 0xee, 0x6f, 0x73, 0xee, 0xbe}
    mailWrite( 0x4c, VC{0x15, 0x81} );
    mailWrite( 0x4c, VC{0x65, 0x8a} );
    mailWrite( 0x4c, VC{0x10, 0x89} );
    mailWrite( 0x4c, VC{0x11, 0x28} );
    mailWrite( 0x4c, VC{0x12, 0x28} );
    mailWrite( 0x4c, VC{0x13, 0xa8} );
    mailWrite( 0x4c, VC{0x14, 0x88} );
    mailWrite( 0x4c, VC{0x15, 0x8b} );
    pollOn0x9989ED();
    readFrom0x9989EC(32); //EXPECTED {0x1c, 0x72, 0x78, 0x4e, 0x7e, 0x42, 0x4b, 0xee, 0xce, 0x34, 0x6e, 0x6e, 0x6e, 0xf0, 0x6f, 0x73, 0xee, 0x76, 0x1f, 0x72, 0x78, 0x4e, 0x36, 0x42, 0x4b, 0x6e, 0xce, 0x34, 0x6e, 0x6e, 0x6e, 0xf0}
    mailWrite( 0x4c, VC{0x15, 0x81} );
    mailWrite( 0x4c, VC{0x65, 0x8a} );
    mailWrite( 0x4c, VC{0x10, 0x89} );
    mailWrite( 0x4c, VC{0x11, 0x28} );
    mailWrite( 0x4c, VC{0x12, 0x48} );
    mailWrite( 0x4c, VC{0x13, 0xa8} );
    mailWrite( 0x4c, VC{0x14, 0x88} );
    mailWrite( 0x4c, VC{0x15, 0x8b} );
    pollOn0x9989ED();
    readFrom0x9989EC(32); //EXPECTED {0x6f, 0x73, 0x6e, 0xd2, 0x3c, 0xbe, 0x70, 0x4e, 0xd6, 0x46, 0x3b, 0x2e, 0xce, 0x34, 0x6e, 0x6e, 0x6e, 0x70, 0xe2, 0x64, 0xbe, 0xfe, 0x4e, 0x2e, 0x5f, 0x4e, 0x62, 0x2e, 0x3b, 0x6e, 0xce, 0x34}
    mailWrite( 0x4c, VC{0x15, 0x81} );
    mailWrite( 0x4c, VC{0x65, 0x8a} );
    mailWrite( 0x4c, VC{0x10, 0x89} );
    mailWrite( 0x4c, VC{0x11, 0x28} );
    mailWrite( 0x4c, VC{0x12, 0x68} );
    mailWrite( 0x4c, VC{0x13, 0xa8} );
    mailWrite( 0x4c, VC{0x14, 0x88} );
    mailWrite( 0x4c, VC{0x15, 0x8b} );
    pollOn0x9989ED();
    readFrom0x9989EC(32); //EXPECTED {0x6e, 0x6e, 0x6e, 0x76, 0xe2, 0x64, 0xbe, 0xe4, 0x4e, 0x8e, 0x43, 0x7e, 0x7e, 0x50, 0xf8, 0x6e, 0xce, 0x34, 0x6e, 0x6e, 0x6e, 0x76, 0x6e, 0x6e, 0x6e, 0x6e, 0x6e, 0x6e, 0x6e, 0x6e, 0x6e, 0x28}

    if ( deviceType_ == DeviceType::GameCaptureHD ) {
        configureCommonBlockC(); //Think this is just a driver choice to move it to just doing it at the end on newer model
    }
    mailWrite( 0x4c, VC{0x0f, 0x88} );
    mailWrite( 0x4c, VC{0x10, 0x89} );
    mailWrite( 0x4c, VC{0x11, 0xfc} );
    mailWrite( 0x4c, VC{0x12, 0xc8} );
    mailWrite( 0x4c, VC{0x13, 0x8b} );
    mailWrite( 0x4c, VC{0x15, 0x88} );
    mailWrite( 0x33, VC{0x99, 0x89, 0xed} );
    mailRead( 0x33, 1 ); //EXPECTED {0xec}
    mailWrite( 0x33, VC{0x99, 0x8a, 0xbf} );
    mailRead( 0x33, 2 ); //EXPECTED {0x6e, 0xe1}
    mailWrite( 0x33, VC{0x99, 0x89, 0xb8} );
    std::vector<uint8_t> readValue=mailRead( 0x33, 1 );

    mailWrite( 0x33, VC{0x99, 0x89, 0xf5} );
    mailRead( 0x33, 1 ); //EXPECTED {0x02}

    mailWrite( 0x33, VC{0x99, 0x89, 0xf5} );
    mailRead( 0x33, 1 ); //EXPECTED {0x02}
    mailWrite( 0x33, VC{0x10, 0x00, 0x33} );

    //I have a theory that this is set to ceil( .95 * Theory read point above
    uint8_t setValue=std::ceil(.95 * readValue[0]);
    mailWrite( 0x33, VC{0x10, 0x01, setValue} );
    mailWrite( 0x33, VC{0x10, 0x02, 0x71} );
    mailWrite( 0x33, VC{0x10, 0x03, 0x72} );

    //Not sure if I should subtract 80 to min zero, or
    //just clear the bit. We'll just clear it.
    setValue &= ~0x80;
    mailWrite( 0x33, VC{0x10, 0x01, setValue} );

    //SPECIAL END
    mailWrite( 0x4c, VC{0x04, 0x95} );

    if ( deviceType_ == DeviceType::GameCaptureHD ) {
        mailWrite( 0x4c, VC{0x0f, 0x88} );
        mailWrite( 0x4c, VC{0xc1, 0x89} );
        mailWrite( 0x4c, VC{0xc6, 0x8b} );
    }
}


void GCHD::configureCommonBlockB1( bool mysteryParameter )
{
	mailWrite( 0x33, VC{0x99, 0x89, 0x89} );
	mailRead( 0x33, 1 ); //EXPECTED {0x6e}
    mailWrite( 0x4c, VC{0x72, 0x88} );
	mailWrite( 0x4c, VC{0xc0, 0x89} );
	mailWrite( 0x4c, VC{0x61, 0x98} );
	mailWrite( 0x4c, VC{0x63, 0x89} );

    //Mystery setting difference.
    if( mysteryParameter ) {
	    mailWrite( 0x4c, VC{0x64, 0xde} );
    } else {
	    mailWrite( 0x4c, VC{0x64, 0x96} );
    }

    mailWrite( 0x4c, VC{0x65, 0x88} );
	mailWrite( 0x33, VC{0x99, 0x89, 0xff} );
	mailRead( 0x33, 1 ); //EXPECTED {0x73}
	mailWrite( 0x4c, VC{0x04, 0x8d} );

    //Mystery setting difference.
    if( mysteryParameter ) {
    	mailWrite( 0x4c, VC{0x62, 0x01} );
    } else {
	    mailWrite( 0x4c, VC{0x62, 0x91} );
    }
}

void GCHD::configureCommonBlockB2()
{
	mailWrite( 0x4c, VC{0x0f, 0x89} );
    mailWrite( 0x4c, VC{0x58, 0xd8} );

    //Not sure if component or HDMI and component use this setting.
    switch (currentInputSettings_.getResolution()) {
        case Resolution::PAL:
        case Resolution::NTSC:
            mailWrite( 0x4c, VC{0x59, 0xd0} );
            break;
        default: //Everything else.
            mailWrite( 0x4c, VC{0x59, 0x20} );
            break;
    }
	mailWrite( 0x4c, VC{0x5a, 0x88} );

    switch(currentInputSettings_.getResolution()) {
        //Wondering if 2 parameters are just inexactly measured,
        //and variance is just noise.
        case Resolution::HD1080:
            if( currentInputSettings_.getScanMode()==ScanMode::Interlaced) { //1080i60
    	        mailWrite( 0x4c, VC{0x5b, 0x8d} );
            } else { //1080p30 Component. 1080p60 HDMI
    	        mailWrite( 0x4c, VC{0x5b, 0x98} );
            }
	        mailWrite( 0x4c, VC{0x5c, 0x88} );
            break;
        case Resolution::HD720:
	        mailWrite( 0x4c, VC{0x5b, 0x8c} );
    	    mailWrite( 0x4c, VC{0x5c, 0x88} );
            break;
        case Resolution::PAL:
            if( currentInputSettings_.getScanMode()==ScanMode::Interlaced) {
                mailWrite( 0x4c, VC{0x5b, 0x9d} );
                mailWrite( 0x4c, VC{0x5c, 0x89} );
            } else {
                mailWrite( 0x4c, VC{0x5b, 0x99} );
                mailWrite( 0x4c, VC{0x5c, 0x88} );
            }
            break;
        case Resolution::NTSC:
            if( currentInputSettings_.getScanMode()==ScanMode::Interlaced) {
                mailWrite( 0x4c, VC{0x5b, 0x8e} );
                mailWrite( 0x4c, VC{0x5c, 0x89} );
            } else {
                mailWrite( 0x4c, VC{0x5b, 0x8a} );
                mailWrite( 0x4c, VC{0x5c, 0x88} );
            }
            break;
        default:
            throw runtime_error( "Current selected video mode is not a supported mode.");
            break;
    }

	mailWrite( 0x4c, VC{0x5e, 0x88} );
	mailWrite( 0x4c, VC{0x5f, 0x88} );
	mailWrite( 0x4c, VC{0x60, 0x88} );
	mailWrite( 0x4c, VC{0x61, 0x88} );
	mailWrite( 0x4c, VC{0x62, 0x88} );
	mailWrite( 0x4c, VC{0x63, 0x88} );
	mailWrite( 0x4c, VC{0x64, 0x88} );
	mailWrite( 0x4c, VC{0x65, 0x88} );

    uint8_t value;
    switch(currentInputSettings_.getResolution()) {
        case Resolution::HD1080:
            if( currentInputSettings_.getScanMode()==ScanMode::Interlaced) { //Component 1080i
                value = 0xfa;
            } else { //Componment 1080p
                value = 0xef;
            }
            break;
        case Resolution::HD720:
        	value = 0xfb;
            break;
        case Resolution::PAL:
            if( currentInputSettings_.getScanMode()==ScanMode::Interlaced) {
                value = 0x39;
            } else {
                value = 0x3e;
            }
            break;
        case Resolution::NTSC:
            if( currentInputSettings_.getScanMode()==ScanMode::Interlaced) {
                value = 0x48;
            } else {
                value = 0x4d;
            }
            break;
        default:
            throw runtime_error( "Current selected video mode is not a supported mode.");
            break;
    }

	mailWrite( 0x4c, VC{0x5d, value} );
	mailWrite( 0x4c, VC{0x0f, 0x88} );
	mailWrite( 0x4c, VC{0xcd, 0x8b} );
	mailWrite( 0x33, VC{0x99, 0x89, 0xff} );
	mailRead( 0x33, 1 ); //EXPECTED {0x6b}
	mailWrite( 0x4c, VC{0x04, 0x8d} );

    uint8_t status;
    uint8_t mask;

    //This is a subroutine in original driver as it happens at a few lone times.
    {
        do {
            mailWrite( 0x33, VC{0x99, 0x89, 0xf5} );
        } while (( mailRead( 0x33, 1 )[0] & 0x90) == 0);

        mailWrite( 0x33, VC{0x99, 0x89, 0xfd} );
        mailRead( 0x33, 1 ); //EXPECTED {0x6e}
        mailWrite( 0x33, VC{0x99, 0x89, 0xfc} );
        mailRead( 0x33, 1 ); //EXPECTED {0x6e}
        mailWrite( 0x33, VC{0x99, 0x89, 0xf3} );
        mailRead( 0x33, 1 ); //EXPECTED {0x7e}
        mailWrite( 0x33, VC{0x99, 0x89, 0xf5} );
        status=mailRead( 0x33, 1 )[0];
        mask=status & 0x10;
        mailWrite( 0x4c, VC{0x0e, (uint8_t) (mask | 0x65)} );
        mailWrite( 0x4c, VC{0x0e, (uint8_t) (mask | 0x64)} );
	    mailWrite( 0x4c, VC{0x0d, 0xc8} );
    }

    status=mailRead( 0x33, 1 )[0];
    mask=value & 0x10;
    mailWrite( 0x4c, VC{0x0e, (uint8_t) (mask | 0x65)} );
    mailWrite( 0x4c, VC{0x0e, (uint8_t) (mask | 0x64)} );
	mailWrite( 0x4c, VC{0x0d, 0xc8} ); //This comes before
                                       //previous 2 statements
                                       //in some captures.

	mailWrite( 0x4c, VC{0x0f, 0x88} );
	mailWrite( 0x4c, VC{0xc1, 0x89} );
	mailWrite( 0x4c, VC{0xc6, 0x8b} );
	mailWrite( 0x4c, VC{0x0f, 0x88} );
	mailWrite( 0x4c, VC{0x61, 0x88} );

    mailWrite( 0x33, VC{0x10, 0x00, 0x33} );
    mailWrite( 0x33, VC{0x10, 0x01, 0xe3} );
    mailWrite( 0x33, VC{0x10, 0x02, 0x71} );
    mailWrite( 0x33, VC{0x10, 0x03, 0x72} );
    mailWrite( 0x33, VC{0x10, 0x01, 0x63} );
    mailWrite( 0x4c, VC{0x0f, 0x89} );

    switch(currentInputSettings_.getResolution()) {
        case Resolution::HD1080:
            if( currentInputSettings_.getScanMode()==ScanMode::Interlaced) { //1080i60
                mailWrite( 0x4c, VC{0x33, 0x08} );
                mailWrite( 0x4c, VC{0x34, 0xa5} );
            } else {
                mailWrite( 0x4c, VC{0x33, 0x88} );
                mailWrite( 0x4c, VC{0x34, 0x90} );
            }
            break;
        case Resolution::HD720:
            mailWrite( 0x4c, VC{0x33, 0x08} );
            mailWrite( 0x4c, VC{0x34, 0xa5} );
            break;
        case Resolution::PAL:
        case Resolution::NTSC:
            mailWrite( 0x4c, VC{0x33, 0x88} );
            mailWrite( 0x4c, VC{0x34, 0x90} );
            break;
        default:
            throw runtime_error( "Current selected video mode is not a supported mode.");
            break;
    }
    mailWrite( 0x4c, VC{0x35, 0x88} );
    mailWrite( 0x4c, VC{0x0f, 0x88} );
    mailWrite( 0x4c, VC{0xc5, 0x88} );
    mailWrite( 0x33, VC{0x99, 0x89, 0xa3} );
    mailRead( 0x33, 1 ); //EXPECTED {0x7f}
    mailWrite( 0x4c, VC{0x58, 0x9d} );
    mailWrite( 0x4c, VC{0x0f, 0x88} );
    mailWrite( 0x33, VC{0x99, 0x89, 0xff} );
    mailRead( 0x33, 1 ); //EXPECTED {0x6b}
    mailWrite( 0x4c, VC{0x04, 0x8d} );
    mailWrite( 0x4c, VC{0xe2, 0x6c} );
    mailWrite( 0x4c, VC{0xe3, 0x88} );
    mailWrite( 0x4c, VC{0xe4, 0x80} );
    mailWrite( 0x4c, VC{0xe0, 0x49} );
    mailWrite( 0x4c, VC{0xe1, 0x89} );
    mailWrite( 0x4c, VC{0x0f, 0x89} );
    mailWrite( 0x4c, VC{0x91, 0x88} );
    mailWrite( 0x4c, VC{0x92, 0x88} );
    mailWrite( 0x4c, VC{0x93, 0x89} );
    mailWrite( 0x4c, VC{0x94, 0xa9} );
    mailWrite( 0x4c, VC{0x95, 0xcb} );
    mailWrite( 0x4c, VC{0x96, 0xed} );
    mailWrite( 0x4c, VC{0x97, 0x0f} );
    mailWrite( 0x4c, VC{0x98, 0x8a} );
    mailWrite( 0x4c, VC{0x99, 0x53} );
    mailWrite( 0x4c, VC{0x0f, 0x88} );
    mailWrite( 0x33, VC{0x99, 0x89, 0xff} );
    mailRead( 0x33, 1 ); //EXPECTED {0x6b}
    mailWrite( 0x4c, VC{0x04, 0x8c} );
    mailWrite( 0x4c, VC{0x0f, 0x89} );
    mailWrite( 0x4c, VC{0x68, 0x89} );
    mailWrite( 0x4c, VC{0x6b, 0x88} );
    mailWrite( 0x4c, VC{0x6c, 0x88} );
    mailWrite( 0x4c, VC{0x6d, 0xf8} );
    mailWrite( 0x4c, VC{0x0f, 0x88} );
    mailWrite( 0x4c, VC{0xce, 0x8b} );
    mailWrite( 0x33, VC{0x99, 0x89, 0xff} );
    mailRead( 0x33, 1 ); //EXPECTED {0x6a}
    mailWrite( 0x4c, VC{0x04, 0x88} );
	mailWrite( 0x4c, VC{0x0f, 0x88} );
	mailWrite( 0x4c, VC{0xc1, 0x88} );
	mailWrite( 0x4c, VC{0xc6, 0x8b} );
}

void GCHD::configureCommonBlockB3()
{
    if (currentInputSettings_.getResolution() != Resolution::PAL) {
        mailWrite( 0x4c, VC{0x0f, 0x89} );
        mailWrite( 0x33, VC{0x99, 0x89, 0x5b} );
        mailRead( 0x33, 1 ); //EXPECTED {0x7c}
        mailWrite( 0x33, VC{0x99, 0x89, 0x5a} );
        mailRead( 0x33, 1 ); //EXPECTED {0x2a}
        mailWrite( 0x33, VC{0x99, 0x89, 0x59} );
        mailRead( 0x33, 1 ); //EXPECTED {0x6c}

        mailWrite( 0x33, VC{0x99, 0x89, 0xc8} );
        mailRead( 0x33, 1 ); //EXPECTED {0x6e}
        mailWrite( 0x33, VC{0x99, 0x89, 0xcf} );
        mailRead( 0x33, 1 ); //EXPECTED {0x76}
        mailWrite( 0x33, VC{0x99, 0x89, 0xce} );
        mailRead( 0x33, 1 ); //EXPECTED {0x6e};
        mailWrite( 0x4c, VC{0x0f, 0x88} );
    }
}

void GCHD::configureCommonBlockC()
{
    mailWrite( 0x33, VC{0xaa, 0xb8, 0x29, 0xf6} );
    mailWrite( 0x33, VC{0xa1, 0x08, 0x73} );
    mailRead( 0x33, 8 ); //EXPECTED {0xe6, 0xa6, 0x33, 0xc0, 0x4d, 0xda, 0x67, 0x0b}
    mailWrite( 0x33, VC{0xa1, 0x08, 0x7b} );
    mailRead( 0x33, 8 ); //EXPECTED {0xf2, 0xb8, 0xcd, 0x3f, 0xb2, 0x25, 0x98, 0x0b}
    mailWrite( 0x33, VC{0xa1, 0x08, 0x63} );
    mailRead( 0x33, 8 ); //EXPECTED {0xf7, 0x4e, 0xcd, 0x3c, 0x32, 0x25, 0x9a, 0x73}
    mailWrite( 0x33, VC{0xa1, 0x08, 0x6b} );
    mailRead( 0x33, 8 ); //EXPECTED {0xfc, 0x96, 0xb8, 0x9c, 0xe5, 0x69, 0x28, 0x28}
    mailWrite( 0x33, VC{0xa1, 0x08, 0x53} );
    mailRead( 0x33, 8 ); //EXPECTED {0xef, 0x11, 0x80, 0x3f, 0xb2, 0x25, 0x19, 0xcb}
    mailWrite( 0x33, VC{0xa1, 0x08, 0x5b} );
    mailRead( 0x33, 8 ); //EXPECTED {0x37, 0x99, 0xcd, 0x3e, 0xb3, 0x24, 0x99, 0x0a}
    mailWrite( 0x33, VC{0xa1, 0x08, 0x43} );
    mailRead( 0x33, 8 ); //EXPECTED {0xe7, 0x58, 0xcd, 0x3e, 0xb3, 0x24, 0x9a, 0x31}
    mailWrite( 0x33, VC{0xa1, 0x08, 0x4b} );
    mailRead( 0x33, 8 ); //EXPECTED {0x66, 0x41, 0xbd, 0x07, 0x9f, 0x65, 0xc0, 0x27}
    mailWrite( 0x33, VC{0xa1, 0x08, 0x33} );
    mailRead( 0x33, 8 ); //EXPECTED {0xa3, 0x59, 0x08, 0xb1, 0x93, 0x25, 0x98, 0x15}
    mailWrite( 0x33, VC{0xa1, 0x08, 0x3b} );
    mailRead( 0x33, 8 ); //EXPECTED {0xe6, 0x59, 0xcc, 0x27, 0xb2, 0x39, 0x8e, 0x2b}
    mailWrite( 0x33, VC{0xa1, 0x08, 0x23} );
    mailRead( 0x33, 8 ); //EXPECTED {0xbe, 0x75, 0xe9, 0x3f, 0x76, 0xab, 0xb9, 0x0b}
    mailWrite( 0x33, VC{0xa1, 0x08, 0x2b} );
    mailRead( 0x33, 8 ); //EXPECTED {0xe6, 0xc7, 0xcc, 0x3f, 0xb2, 0xd9, 0x98, 0x4e}
    mailWrite( 0x33, VC{0xa1, 0x08, 0x13} );
    mailRead( 0x33, 8 ); //EXPECTED {0x8a, 0x3e, 0xad, 0x4b, 0xdd, 0x2f, 0xb8, 0x2b}
    mailWrite( 0x33, VC{0xa1, 0x08, 0x1b} );
    mailRead( 0x33, 8 ); //EXPECTED {0xc6, 0x79, 0xec, 0x1f, 0xb2, 0x25, 0x98, 0xf6}
    mailWrite( 0x33, VC{0xa1, 0x08, 0x03} );
    mailRead( 0x33, 8 ); //EXPECTED {0xe6, 0x4e, 0xf1, 0x26, 0xf4, 0x2a, 0x98, 0x01}
    mailWrite( 0x33, VC{0xa1, 0x08, 0x0b} );
    mailRead( 0x33, 8 ); //EXPECTED {0xc6, 0x79, 0xec, 0x1f, 0x92, 0x05, 0x99, 0xee}
    mailWrite( 0x33, VC{0xa1, 0x08, 0xf3} );
    mailRead( 0x33, 8 ); //EXPECTED {0xe4, 0x5a, 0xea, 0xcb, 0xe3, 0xa0, 0x9c, 0x08}
    mailWrite( 0x33, VC{0xa1, 0x08, 0xfb} );
    mailRead( 0x33, 8 ); //EXPECTED {0xe4, 0x4b, 0xdf, 0xab, 0xa4, 0x22, 0x9e, 0x1a}
    mailWrite( 0x33, VC{0xa1, 0x08, 0xe3} );
    mailRead( 0x33, 8 ); //EXPECTED {0xf3, 0xf8, 0x6e, 0x18, 0xad, 0x35, 0xbb, 0x02}
    mailWrite( 0x33, VC{0xa1, 0x08, 0xeb} );
    mailRead( 0x33, 8 ); //EXPECTED {0xe1, 0x58, 0x4f, 0x3e, 0xb2, 0x25, 0xff, 0x08}
    mailWrite( 0x33, VC{0xa1, 0x08, 0xd3} );
    mailRead( 0x33, 8 ); //EXPECTED {0xea, 0x59, 0xdc, 0x3f, 0x92, 0x08, 0x14, 0x01}
    mailWrite( 0x33, VC{0xa1, 0x08, 0xdb} );
    mailRead( 0x33, 8 ); //EXPECTED {0x46, 0x4d, 0x9d, 0xcf, 0xa4, 0x25, 0xbe, 0x77}
    mailWrite( 0x33, VC{0xa1, 0x08, 0xc3} );
    mailRead( 0x33, 8 ); //EXPECTED {0xa5, 0x59, 0x08, 0xb1, 0x93, 0x25, 0x98, 0x93}
    mailWrite( 0x33, VC{0xa1, 0x08, 0xcb} );
    mailRead( 0x33, 8 ); //EXPECTED {0x6a, 0x53, 0x1c, 0xb5, 0x92, 0xc5, 0xb5, 0x1b}
    mailWrite( 0x33, VC{0xa1, 0x08, 0xb3} );
    mailRead( 0x33, 8 ); //EXPECTED {0xf6, 0x67, 0x5a, 0x3f, 0x76, 0xab, 0xb9, 0x0b}
    mailWrite( 0x33, VC{0xa1, 0x08, 0xbb} );
    mailRead( 0x33, 8 ); //EXPECTED {0xe6, 0x40, 0xcd, 0x22, 0xb2, 0x57, 0xc9, 0xdb}
    mailWrite( 0x33, VC{0xa1, 0x08, 0xa3} );
    mailRead( 0x33, 8 ); //EXPECTED {0xf8, 0x79, 0xa2, 0x17, 0xe7, 0x25, 0x5c, 0x85}
    mailWrite( 0x33, VC{0xa1, 0x08, 0xab} );
    mailRead( 0x33, 8 ); //EXPECTED {0xc7, 0x59, 0xcc, 0x20, 0xb3, 0x38, 0x18, 0x13}
    mailWrite( 0x33, VC{0xa1, 0x08, 0x93} );
    mailRead( 0x33, 8 ); //EXPECTED {0x97, 0x45, 0xda, 0x1f, 0xea, 0x09, 0xbd, 0x0b}
    mailWrite( 0x33, VC{0xa1, 0x08, 0x9b} );
    mailRead( 0x33, 8 ); //EXPECTED {0x22, 0xd7, 0xed, 0x3f, 0xb2, 0xbb, 0x98, 0x0b}
    mailWrite( 0x33, VC{0xa1, 0x08, 0x83} );
    mailRead( 0x33, 8 ); //EXPECTED {0xe6, 0x59, 0xcc, 0x3f, 0xb2, 0x25, 0x98, 0x0b}
    mailWrite( 0x33, VC{0xa1, 0x08, 0x8b} );
    mailRead( 0x33, 8 ); //EXPECTED {0xe6, 0x59, 0xcc, 0x3f, 0xb2, 0x25, 0x98, 0x04}
    mailWrite( 0x33, VC{0xaa, 0xb8, 0x29, 0xe7} );
}


